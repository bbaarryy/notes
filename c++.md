# Здесь все о с++

## vector 
Динамический контейнер, который резервирует память для последующего расширения.
За счет этого снижается сложность добавления элементов в конец.
Вектор хранит элементы в линейном расположении и обеспечивает быстрый случайный доступ к любому элементу.
Для быстрой работы не встроена валидация индекса. Для работы с элементами по индексу без уверенности корректности этого индекса
можно использовать *vector.at(index)*
Если *index >= vector.size()* произойдёт исключение **out_of_range** — его можно будет перехватить 
*try {...} catch (const out_of_range){...}*

Почти все методы работают за O(1)
**Кроме**
- конструктора вектора : О(n)
- оператора сравнения и присваивания : O(n)
- .clear : O(n)
- вставки в случайное место : O(n)
- .erase : O(n)
- .resize : O(n)

## set
Контейнер, хранящий уникальные отсортированные элементы. Поиск, удаление, вставка - всё это работает за *log(n)*.
- удаление: set.erase(либо значение элемента, либо итератор, либо отрезок элементов);
- вставка: set.insert(значение элемента);
- поиск итератора на элемент: set.find(element), если нет такого - возврат на set.end()
- поиск первого элемента >= нужного: первый элемент >= нужного *= set.lower_bound(*нужное значение*)*;
### advance(it, n) - сдвиг итератора на сколько-то значений вправо(+)/влево(-)

## map
Контейнер, хранящий пары уникальный ключ-значение

Причем итератором можно ->first ->second узнать ключ\значение соответственно

Так можно изменить значение , НО НЕ КЛЮЧ

- вставка новых пар : map[key] = value *O(log n)*
- удаление по ключу : то же, что и в set *O(log n)*
- поиск по ключу: map[key] = ... *O(log n)*
- вывод размера: map.size() *O(log n)*

Однако, сложность работы много больше , чем чистый log(n), есть константа , поэтому можно использовать unordered_map - он
не сортирует ключи, в отличие от обычного map
